<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <meta name="theme-color" content="#070b12" />
    <link rel="manifest" href="manifest.webmanifest" />
    <title>Air Hockey Pro (PWA)</title>

    <style>
        :root {
            --bg: #070b12;
            --panel: rgba(18, 26, 36, .78);
            --panel2: rgba(18, 26, 36, .60);
            --line: rgba(255, 255, 255, .12);
            --text: #e9f0ff;
            --muted: #a9b6cc;
            --gold: #ffd66e;
            --ice: #cfe6ff;
            --blue: #2aa5ff;
            --red: #ff4b6e;
            --shadow: 0 18px 60px rgba(0, 0, 0, .45);
            --radius: 16px;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
            overflow: hidden;
            touch-action: none;
            -webkit-text-size-adjust: 100%;
        }

        /* Use dynamic viewport on Android */
        .vh {
            height: 100vh;
        }

        @supports (height: 100dvh) {
            .vh {
                height: 100dvh;
            }
        }

        #wrap {
            position: fixed;
            inset: 0;
        }

        canvas {
            width: 100vw;
            height: 100%;
            display: block;
            background: var(--bg);
            touch-action: none;
        }

        /* Top bar with neon scoreboard */
        .topbar {
            position: fixed;
            top: env(safe-area-inset-top, 0px);
            left: 0;
            right: 0;
            padding: 10px 10px 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            z-index: 10;
            pointer-events: none;
        }

        .leftBtns,
        .rightBtns {
            display: flex;
            gap: 8px;
            align-items: center;
            pointer-events: auto;
        }

        .btn {
            background: rgba(18, 26, 36, .65);
            border: 1px solid rgba(255, 255, 255, .14);
            color: var(--text);
            padding: 10px 10px;
            border-radius: 12px;
            font-weight: 950;
            user-select: none;
            cursor: pointer;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 22px rgba(0, 0, 0, .18);
            line-height: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn:active {
            transform: translateY(1px);
        }

        .btn.small {
            padding: 9px 10px;
        }

        .btn.text {
            line-height: normal;
        }

        .btn.primary {
            border-color: rgba(255, 214, 110, .30);
            background: rgba(255, 214, 110, .14);
        }

        .scoreNeon {
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 14px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, .12);
            background: rgba(18, 26, 36, .52);
            backdrop-filter: blur(10px);
            box-shadow: 0 14px 30px rgba(0, 0, 0, .28);
            max-width: 72vw;
            overflow: hidden;
            white-space: nowrap;
        }

        .scoreNeon .mode {
            font-weight: 980;
            letter-spacing: .6px;
            font-size: 12px;
            padding: 5px 10px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, .12);
            background: rgba(255, 255, 255, .06);
            text-transform: uppercase;
            flex: 0 0 auto;
        }

        .scoreNeon .score {
            font-weight: 980;
            letter-spacing: .4px;
            font-size: 14px;
            text-transform: uppercase;
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1 1 auto;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .glowText {
            text-shadow:
                0 0 6px rgba(42, 165, 255, .35),
                0 0 16px rgba(42, 165, 255, .20),
                0 0 28px rgba(255, 214, 110, .12);
            animation: neonPulse 2.2s ease-in-out infinite;
        }

        @keyframes neonPulse {

            0%,
            100% {
                filter: brightness(1);
            }

            50% {
                filter: brightness(1.15);
            }
        }

        .sep {
            opacity: .55;
        }

        /* Thumb pad HUD (bottom) */
        .thumbpad {
            position: fixed;
            left: env(safe-area-inset-left, 0px);
            bottom: env(safe-area-inset-bottom, 0px);
            padding: 12px;
            z-index: 9;
            pointer-events: none;
            /* only joystick itself uses pointer events */
        }

        .joy {
            pointer-events: auto;
            width: 132px;
            height: 132px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, .12);
            background:
                radial-gradient(circle at 50% 50%, rgba(255, 255, 255, .08), rgba(0, 0, 0, .25));
            backdrop-filter: blur(10px);
            box-shadow: 0 18px 50px rgba(0, 0, 0, .35);
            position: relative;
            overflow: hidden;
            touch-action: none;
        }

        .joy::after {
            content: "";
            position: absolute;
            inset: 18px;
            border-radius: 999px;
            border: 1px dashed rgba(255, 255, 255, .16);
            opacity: .8;
        }

        .knob {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 56px;
            height: 56px;
            margin-left: -28px;
            margin-top: -28px;
            border-radius: 999px;
            background:
                radial-gradient(circle at 35% 30%, rgba(255, 255, 255, .18), rgba(255, 214, 110, .14) 35%, rgba(0, 0, 0, .22));
            border: 1px solid rgba(255, 255, 255, .14);
            box-shadow: 0 12px 24px rgba(0, 0, 0, .25);
            transform: translate(0, 0);
            transition: transform .08s linear;
        }

        .joyLabel {
            margin-top: 8px;
            font-weight: 900;
            font-size: 12px;
            color: rgba(233, 240, 255, .78);
            text-shadow: 0 0 10px rgba(42, 165, 255, .18);
            user-select: none;
            pointer-events: none;
        }

        /* Overlays */
        .overlay {
            position: fixed;
            inset: 0;
            z-index: 20;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 16px;
            background: radial-gradient(1000px 700px at 50% 35%, rgba(255, 255, 255, .10), rgba(0, 0, 0, .72));
            backdrop-filter: blur(6px);
        }

        .card {
            width: min(560px, 96vw);
            border-radius: var(--radius);
            background: rgba(18, 26, 36, .82);
            border: 1px solid rgba(255, 255, 255, .12);
            padding: 14px;
            box-shadow: var(--shadow);
        }

        .title {
            margin: 0 0 6px;
            font-size: 18px;
            font-weight: 980;
            letter-spacing: .2px;
        }

        .sub {
            margin: 0 0 12px;
            color: var(--muted);
            line-height: 1.45;
            font-size: 13px;
        }

        .row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .row.tight {
            gap: 8px;
        }

        select,
        label.chk {
            background: rgba(255, 255, 255, .08);
            border: 1px solid rgba(255, 255, 255, .14);
            color: var(--text);
            padding: 10px 10px;
            border-radius: 12px;
            font-weight: 950;
            outline: none;
            flex: 1 1 200px;
            min-width: 160px;
        }

        label.chk {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            flex: 1 1 180px;
        }

        label.chk input {
            accent-color: var(--gold);
        }

        .stat {
            border: 1px solid rgba(255, 255, 255, .10);
            background: rgba(0, 0, 0, .18);
            border-radius: 14px;
            padding: 10px 12px;
            font-weight: 950;
        }

        .stat small {
            display: block;
            color: var(--muted);
            font-weight: 800;
            margin-bottom: 6px;
        }

        .hide {
            display: none !important;
        }

        @media (max-width: 420px) {
            .joy {
                width: 120px;
                height: 120px;
            }

            .knob {
                width: 52px;
                height: 52px;
                margin-left: -26px;
                margin-top: -26px;
            }

            select,
            label.chk {
                min-width: 140px;
            }

            .scoreNeon {
                max-width: 68vw;
                padding: 9px 12px;
            }

            .scoreNeon .score {
                font-size: 13px;
            }

            .btn {
                padding: 9px 10px;
            }
        }
    </style>
</head>

<body>
    <div id="wrap" class="vh">
        <canvas id="c"></canvas>
    </div>

    <!-- Topbar -->
    <div class="topbar" id="topbar">
        <div class="leftBtns">
            <button class="btn small" id="gearBtn" aria-label="Settings">
                <!-- gear icon -->
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                    <path d="M12 15.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7Z" stroke="currentColor" stroke-width="2" />
                    <path
                        d="M19.4 15a7.96 7.96 0 0 0 .1-1l2-1.2-2-3.5-2.3.6a8.4 8.4 0 0 0-1.7-1l-.3-2.4H9.8l-.3 2.4a8.4 8.4 0 0 0-1.7 1l-2.3-.6-2 3.5 2 1.2a7.96 7.96 0 0 0 .1 1 7.96 7.96 0 0 0-.1 1l-2 1.2 2 3.5 2.3-.6c.5.4 1.1.7 1.7 1l.3 2.4h4.4l.3-2.4c.6-.3 1.2-.6 1.7-1l2.3.6 2-3.5-2-1.2a7.96 7.96 0 0 0-.1-1Z"
                        stroke="currentColor" stroke-width="2" stroke-linejoin="round" />
                </svg>
            </button>

            <button class="btn small text ghost" id="pauseBtn">Pause</button>
        </div>

        <div class="scoreNeon" id="scoreNeon">
            <div class="mode glowText" id="modeTag">NORMAL</div>
            <div class="score glowText">
                <span>YOU <span id="sYou">0</span></span>
                <span class="sep">:</span>
                <span><span id="sAI">0</span> AI</span>
                <span class="sep">•</span>
                <span id="personaTag" style="opacity:.86;">DEFENSIVE</span>
            </div>
        </div>

        <div class="rightBtns">
            <button class="btn small text" id="resetBtn">Reset</button>
        </div>
    </div>

    <!-- Thumb joystick -->
    <div class="thumbpad">
        <div class="joy" id="joy">
            <div class="knob" id="knob"></div>
        </div>
        <div class="joyLabel">Thumb Control</div>
    </div>

    <!-- Start overlay (minimal) -->
    <div class="overlay" id="startOverlay">
        <div class="card">
            <h1 class="title">Air Hockey Pro</h1>
            <p class="sub">
                Use the <b>thumb pad</b> to move your paddle without covering it.
                Tap the board to serve. Install for best Android experience.
            </p>
            <div class="row">
                <button class="btn primary text" id="startBtn" style="flex:1 1 220px;">Start Match</button>
                <button class="btn text" id="installBtn" style="flex:1 1 160px;">Install</button>
            </div>
            <div class="stat" style="margin-top:10px;">
                <small>Tip</small>
                If your phone hides UI bars, install the PWA and run it from the home screen.
            </div>
        </div>
    </div>

    <!-- Pause overlay -->
    <div class="overlay hide" id="pauseOverlay">
        <div class="card">
            <h2 class="title" style="margin-bottom:6px;">Paused</h2>
            <p class="sub" style="margin-bottom:12px;">Resume when you’re ready.</p>
            <div class="row">
                <button class="btn primary text" id="resumeBtn" style="flex:1 1 200px;">Resume</button>
                <button class="btn text" id="menuBtn" style="flex:1 1 200px;">Main Menu</button>
            </div>
        </div>
    </div>

    <!-- Settings modal -->
    <div class="overlay hide" id="settingsOverlay">
        <div class="card">
            <h2 class="title" style="margin-bottom:6px;">Settings</h2>
            <p class="sub">Difficulty, AI personality, sound and haptics.</p>

            <div class="row">
                <select id="diffSel">
                    <option value="easy">Easy</option>
                    <option value="normal" selected>Normal</option>
                    <option value="smart">Smart</option>
                    <option value="hard">Hard</option>
                    <option value="pro">Pro</option>
                    <option value="legendary">Legendary (Learns you)</option>
                </select>

                <select id="personaSel">
                    <option value="defensive" selected>AI: Defensive</option>
                    <option value="aggressive">AI: Aggressive</option>
                    <option value="trickshot">AI: Trickshot</option>
                </select>
            </div>

            <div class="row tight">
                <label class="chk">
                    <input type="checkbox" id="soundToggle" checked />
                    Sound
                </label>

                <label class="chk">
                    <input type="checkbox" id="hapticsToggle" checked />
                    Haptics (Android)
                </label>
            </div>

            <div class="row">
                <div class="stat" style="flex: 1 1 240px;">
                    <small>Legendary profile</small>
                    <div id="profileLine">Collecting data…</div>
                </div>
                <div class="stat" style="flex: 1 1 240px;">
                    <small>Target</small>
                    <div>First to <span id="targetLabel">7</span></div>
                </div>
            </div>

            <div class="row" style="margin-top:12px;">
                <button class="btn text" id="resetLearningBtn" style="flex:1 1 220px;">Reset AI Learning</button>
                <button class="btn primary text" id="closeSettingsBtn" style="flex:1 1 160px;">Close</button>
            </div>
        </div>
    </div>

    <script>
        (() => {
            // ---------------- PWA install prompt ----------------
            let deferredPrompt = null;
            window.addEventListener("beforeinstallprompt", (e) => {
                e.preventDefault();
                deferredPrompt = e;
            });

            // SW
            if ("serviceWorker" in navigator) {
                window.addEventListener("load", async () => {
                    try { await navigator.serviceWorker.register("./sw.js"); } catch { }
                });
            }

            // ---------------- DOM ----------------
            const canvas = document.getElementById("c");
            const ctx = canvas.getContext("2d", { alpha: false });

            const ui = {
                sYou: document.getElementById("sYou"),
                sAI: document.getElementById("sAI"),
                modeTag: document.getElementById("modeTag"),
                personaTag: document.getElementById("personaTag"),

                startOverlay: document.getElementById("startOverlay"),
                startBtn: document.getElementById("startBtn"),
                installBtn: document.getElementById("installBtn"),

                pauseBtn: document.getElementById("pauseBtn"),
                resetBtn: document.getElementById("resetBtn"),

                pauseOverlay: document.getElementById("pauseOverlay"),
                resumeBtn: document.getElementById("resumeBtn"),
                menuBtn: document.getElementById("menuBtn"),

                settingsOverlay: document.getElementById("settingsOverlay"),
                gearBtn: document.getElementById("gearBtn"),
                closeSettingsBtn: document.getElementById("closeSettingsBtn"),

                diffSel: document.getElementById("diffSel"),
                personaSel: document.getElementById("personaSel"),
                soundToggle: document.getElementById("soundToggle"),
                hapticsToggle: document.getElementById("hapticsToggle"),
                resetLearningBtn: document.getElementById("resetLearningBtn"),
                profileLine: document.getElementById("profileLine"),
                targetLabel: document.getElementById("targetLabel"),

                joy: document.getElementById("joy"),
                knob: document.getElementById("knob"),
            };

            // ---------------- Resize (Android fit) ----------------
            function resize() {
                const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
                canvas.width = Math.floor(innerWidth * dpr);
                canvas.height = Math.floor(innerHeight * dpr);
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            }
            addEventListener("resize", resize, { passive: true });
            resize();
            const dims = () => ({ w: innerWidth, h: innerHeight });
            const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

            // ---------------- Haptics ----------------
            function vibrate(pattern) {
                if (!ui.hapticsToggle.checked) return;
                if (!("vibrate" in navigator)) return;
                try { navigator.vibrate(pattern); } catch { }
            }

            // ---------------- Audio (generated, no assets) ----------------
            let audioCtx = null;
            function ensureAudio() {
                if (!ui.soundToggle.checked) return;
                if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                if (audioCtx.state === "suspended") audioCtx.resume().catch(() => { });
            }
            function beep(type, freq, dur, gain) {
                if (!ui.soundToggle.checked) return;
                ensureAudio();
                if (!audioCtx) return;
                const t0 = audioCtx.currentTime;
                const o = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                o.type = type;
                o.frequency.setValueAtTime(freq, t0);
                g.gain.setValueAtTime(0.0001, t0);
                g.gain.exponentialRampToValueAtTime(Math.max(0.0002, gain), t0 + 0.01);
                g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
                o.connect(g).connect(audioCtx.destination);
                o.start(t0);
                o.stop(t0 + dur + 0.02);
            }
            const sfx = {
                hit: (k) => beep("triangle", 140 + 140 * k, 0.07, 0.07 + 0.18 * k),
                wall: () => beep("sine", 720, 0.06, 0.06),
                goal: () => {
                    beep("square", 520, 0.10, 0.10);
                    setTimeout(() => beep("square", 780, 0.10, 0.09), 90);
                    setTimeout(() => beep("square", 1040, 0.12, 0.08), 180);
                },
                win: () => {
                    beep("sawtooth", 440, 0.14, 0.10);
                    setTimeout(() => beep("sawtooth", 660, 0.14, 0.09), 140);
                    setTimeout(() => beep("sawtooth", 880, 0.18, 0.08), 280);
                }
            };
            window.addEventListener("pointerdown", ensureAudio, { passive: true });

            // ---------------- Game constants ----------------
            const GAME = { targetScore: 7, fixedDt: 1 / 120, maxFrame: 1 / 30 };
            const table = { wall: 10, pad: 22, goalWidthFrac: 0.34 };

            ui.targetLabel.textContent = String(GAME.targetScore);

            // Entities
            const puck = { x: 0, y: 0, r: 10, vx: 0, vy: 0, max: 1600, glow: 0 };
            const you = { x: 0, y: 0, r: 22, vx: 0, vy: 0 };
            const ai = { x: 0, y: 0, r: 22, vx: 0, vy: 0 };

            // Particles
            const sparks = [];
            function addSparks(x, y, n, strength) {
                for (let i = 0; i < n; i++) {
                    sparks.push({
                        x, y,
                        vx: (Math.random() * 2 - 1) * (120 + 260 * strength),
                        vy: (Math.random() * 2 - 1) * (120 + 260 * strength),
                        life: 0.18 + Math.random() * 0.22
                    });
                }
            }

            // ---------------- Learning profile ----------------
            const PROFILE_KEY = "ah_profile_v3";
            function makeFreshProfile() { return { samples: 0, emaShotDir: 0, lastUpdate: Date.now() }; }
            function loadProfile() { try { const r = localStorage.getItem(PROFILE_KEY); return r ? JSON.parse(r) : null; } catch { return null; } }
            function saveProfile(p) { try { localStorage.setItem(PROFILE_KEY, JSON.stringify(p)); } catch { } }
            let profile = loadProfile() || makeFreshProfile();

            function updateProfileUI() {
                if (!profile || profile.samples < 10) {
                    ui.profileLine.textContent = "Collecting data…";
                    return;
                }
                const bias = profile.emaShotDir < -0.15 ? "Left" : (profile.emaShotDir > 0.15 ? "Right" : "Balanced");
                ui.profileLine.textContent = `${profile.samples} hits • bias: ${bias}`;
            }
            updateProfileUI();

            // ---------------- State ----------------
            const state = {
                running: false,
                paused: true,
                gameOver: false,
                message: "",
                scoreYou: 0,
                scoreAI: 0,
                diff: ui.diffSel.value,
                persona: ui.personaSel.value,

                last: performance.now(),
                acc: 0,

                // touch input (board tap to serve)
                pointerDown: false,
                lastPuckV: { vx: 0, vy: 0 },

                // thumbpad
                joyActive: false,
                joyId: null,
                joyCenter: { x: 0, y: 0 },
                joyVec: { x: 0, y: 0 },     // -1..1
            };

            function applyModeTags() {
                ui.modeTag.textContent = state.diff.toUpperCase();
                ui.personaTag.textContent = state.persona.toUpperCase();
            }
            applyModeTags();

            // ---------------- Difficulty + personality ----------------
            function baseParamsByDifficulty(d) {
                switch (d) {
                    case "easy": return { speed: 1020, pressure: 0.30, predict: 0.40, shotPower: 0.65, adapt: 0.08, learn: 0.00 };
                    case "normal": return { speed: 1250, pressure: 0.48, predict: 0.58, shotPower: 0.78, adapt: 0.12, learn: 0.00 };
                    case "smart": return { speed: 1400, pressure: 0.60, predict: 0.70, shotPower: 0.86, adapt: 0.16, learn: 0.06 };
                    case "hard": return { speed: 1560, pressure: 0.72, predict: 0.82, shotPower: 0.92, adapt: 0.20, learn: 0.08 };
                    case "pro": return { speed: 1720, pressure: 0.82, predict: 0.90, shotPower: 0.96, adapt: 0.24, learn: 0.10 };
                    case "legendary": return { speed: 1880, pressure: 0.90, predict: 0.95, shotPower: 0.99, adapt: 0.30, learn: 0.22 };
                    default: return { speed: 1250, pressure: 0.48, predict: 0.58, shotPower: 0.78, adapt: 0.12, learn: 0.00 };
                }
            }

            function personaModifiers(persona) {
                switch (persona) {
                    case "defensive": return { pressureMul: 0.85, bankBias: 0.40, goalieSnap: 1.15, trickRate: 0.10 };
                    case "aggressive": return { pressureMul: 1.20, bankBias: 0.55, goalieSnap: 0.95, trickRate: 0.12 };
                    case "trickshot": return { pressureMul: 1.05, bankBias: 0.85, goalieSnap: 1.00, trickRate: 0.32 };
                    default: return { pressureMul: 1.00, bankBias: 0.55, goalieSnap: 1.00, trickRate: 0.12 };
                }
            }

            function effectiveAIParams() {
                const base = baseParamsByDifficulty(state.diff);
                const pm = personaModifiers(state.persona);

                const diffScore = (state.scoreYou - state.scoreAI);
                const boost = clamp(diffScore * base.adapt, -0.18, 0.40);

                let learnBoost = 0;
                if (state.diff === "legendary") learnBoost = clamp(profile.samples / 250, 0, 0.25);

                return {
                    speed: base.speed * (1 + boost + learnBoost * 0.30),
                    pressure: clamp(base.pressure * pm.pressureMul + boost * 0.8 + learnBoost * 0.25, 0.25, 0.98),
                    predict: clamp(base.predict + boost * 0.6 + learnBoost * 0.25, 0.35, 0.99),
                    shotPower: clamp(base.shotPower + boost * 0.25 + learnBoost * 0.20, 0.60, 1.0),
                    bankBias: pm.bankBias,
                    goalieSnap: pm.goalieSnap,
                    trickRate: pm.trickRate,
                    learn: base.learn
                };
            }

            // ---------------- Thumbpad control ----------------
            // The joystick controls paddle by velocity-style movement so the finger never blocks the puck.
            function setKnob(x, y) {
                ui.knob.style.transform = `translate(${x}px, ${y}px)`;
            }
            function resetKnob() {
                ui.knob.style.transform = `translate(0px, 0px)`;
            }

            ui.joy.addEventListener("pointerdown", (e) => {
                e.preventDefault();
                ui.joy.setPointerCapture(e.pointerId);
                state.joyActive = true;
                state.joyId = e.pointerId;

                const r = ui.joy.getBoundingClientRect();
                state.joyCenter.x = r.left + r.width / 2;
                state.joyCenter.y = r.top + r.height / 2;

                handleJoyMove(e.clientX, e.clientY);
            }, { passive: false });

            ui.joy.addEventListener("pointermove", (e) => {
                if (!state.joyActive || e.pointerId !== state.joyId) return;
                handleJoyMove(e.clientX, e.clientY);
            }, { passive: true });

            ui.joy.addEventListener("pointerup", (e) => {
                if (e.pointerId !== state.joyId) return;
                state.joyActive = false;
                state.joyId = null;
                state.joyVec.x = 0; state.joyVec.y = 0;
                resetKnob();
            }, { passive: true });

            ui.joy.addEventListener("pointercancel", (e) => {
                if (e.pointerId !== state.joyId) return;
                state.joyActive = false;
                state.joyId = null;
                state.joyVec.x = 0; state.joyVec.y = 0;
                resetKnob();
            }, { passive: true });

            function handleJoyMove(x, y) {
                const dx = x - state.joyCenter.x;
                const dy = y - state.joyCenter.y;
                const maxR = 46; // knob travel radius
                const len = Math.hypot(dx, dy) || 1;
                const cl = Math.min(maxR, len);
                const nx = (dx / len) * cl;
                const ny = (dy / len) * cl;

                // normalize -1..1
                state.joyVec.x = nx / maxR;
                state.joyVec.y = ny / maxR;

                setKnob(nx, ny);
            }

            // Tap board to serve
            canvas.addEventListener("pointerdown", (e) => {
                // if settings open, ignore
                if (!state.running) return;
                if (state.paused && !state.gameOver) serve();
            }, { passive: true });

            // ---------------- UI actions ----------------
            ui.installBtn.addEventListener("click", async () => {
                if (!deferredPrompt) return;
                deferredPrompt.prompt();
                try { await deferredPrompt.userChoice; } catch { }
                deferredPrompt = null;
            });

            ui.startBtn.addEventListener("click", () => {
                state.running = true;
                state.paused = true;
                state.gameOver = false;
                ui.startOverlay.classList.add("hide");
                resetPositions();
                state.message = "Tap to serve";
            });

            ui.resetBtn.addEventListener("click", () => {
                state.scoreYou = 0; state.scoreAI = 0;
                ui.sYou.textContent = "0";
                ui.sAI.textContent = "0";
                state.gameOver = false;
                state.paused = true;
                resetPositions();
                state.message = "Tap to serve";
            });

            ui.pauseBtn.addEventListener("click", () => {
                if (!state.running || state.gameOver) return;
                togglePause();
            });

            ui.resumeBtn.addEventListener("click", () => togglePause(false));
            ui.menuBtn.addEventListener("click", () => {
                ui.pauseOverlay.classList.add("hide");
                ui.startOverlay.classList.remove("hide");
                state.running = false;
                state.paused = true;
                state.gameOver = false;
                resetPositions();
            });

            ui.gearBtn.addEventListener("click", () => {
                ui.settingsOverlay.classList.remove("hide");
                // sync dropdowns
                ui.diffSel.value = state.diff;
                ui.personaSel.value = state.persona;
                updateProfileUI();
            });

            ui.closeSettingsBtn.addEventListener("click", () => {
                ui.settingsOverlay.classList.add("hide");
            });

            ui.diffSel.addEventListener("change", () => {
                state.diff = ui.diffSel.value;
                applyModeTags();
            });

            ui.personaSel.addEventListener("change", () => {
                state.persona = ui.personaSel.value;
                applyModeTags();
            });

            ui.resetLearningBtn.addEventListener("click", () => {
                try { localStorage.removeItem(PROFILE_KEY); } catch { }
                profile = makeFreshProfile();
                updateProfileUI();
            });

            function togglePause(force) {
                const next = (typeof force === "boolean") ? force : !state.paused;
                state.paused = next;
                if (state.paused) {
                    ui.pauseOverlay.classList.remove("hide");
                    state.message = "Paused";
                } else {
                    ui.pauseOverlay.classList.add("hide");
                    state.message = "";
                }
            }

            // ---------------- Core game helpers ----------------
            function resetPositions() {
                const { w, h } = dims();
                puck.x = w / 2; puck.y = h / 2; puck.vx = 0; puck.vy = 0; puck.glow = 0;
                you.x = w / 2; you.y = h * 0.78; you.vx = you.vy = 0;
                ai.x = w / 2; ai.y = h * 0.22; ai.vx = ai.vy = 0;
                sparks.length = 0;
                state.lastPuckV.vx = 0; state.lastPuckV.vy = 0;
            }

            function serve() {
                if (!state.running || !state.paused || state.gameOver) return;
                ensureAudio();
                const dir = (Math.random() < 0.5) ? -1 : 1;
                const ang = (Math.random() * 0.55 - 0.275);
                const speed = 560;
                puck.vx = Math.sin(ang) * speed;
                puck.vy = dir * Math.cos(ang) * speed;
                state.paused = false;
                state.message = "";
            }

            function collideDisc(pad) {
                const dx = puck.x - pad.x;
                const dy = puck.y - pad.y;
                const dist = Math.hypot(dx, dy);
                const minD = pad.r + puck.r;
                if (dist <= 0.0001 || dist >= minD) return false;

                const nx = dx / dist, ny = dy / dist;
                const overlap = (minD - dist);
                puck.x += nx * overlap;
                puck.y += ny * overlap;

                const rvx = puck.vx - pad.vx;
                const rvy = puck.vy - pad.vy;
                const vn = rvx * nx + rvy * ny;
                if (vn > z > 0) return true; // (typo safeguard below)
                // Fix: if vn > 0 just return true
            }

            // Safety fix for the line above (in case browser caches): redefine correctly
            function collideDiscSafe(pad) {
                const dx = puck.x - pad.x;
                const dy = puck.y - pad.y;
                const dist = Math.hypot(dx, dy);
                const minD = pad.r + puck.r;
                if (dist <= 0.0001 || dist >= minD) return false;

                const nx = dx / dist, ny = dy / dist;
                const overlap = (minD - dist);
                puck.x += nx * overlap;
                puck.y += ny * overlap;

                const rvx = puck.vx - pad.vx;
                const rvy = puck.vy - pad.vy;
                const vn = rvx * nx + rvy * ny;
                if (vn > 0) return true;

                const restitution = 0.985;
                const j = -(1 + restitution) * vn;
                puck.vx += j * nx;
                puck.vy += j * ny;

                puck.vx += pad.vx * 0.32;
                puck.vy += pad.vy * 0.32;

                const tx = -ny, ty = nx;
                const vt = rvx * tx + rvy * ty;
                puck.vx += tx * vt * 0.02;
                puck.vy += ty * vt * 0.02;

                const hit = clamp(Math.abs(vn) / 950, 0, 1);
                puck.glow = Math.min(1, puck.glow + 0.55 * hit);
                sfx.hit(hit);
                addSparks(puck.x, puck.y, 10 + Math.floor(10 * hit), hit);
                vibrate(hit > 0.55 ? [12, 18, 12] : 10);
                return true;
            }

            function puckWallsGoals() {
                const { w, h } = dims();
                const goalW = w * table.goalWidthFrac;
                const gx1 = (w - goalW) / 2;
                const gx2 = (w + goalW) / 2;
                const inMouth = (puck.x > gx1 && puck.x < gx2);

                if (puck.y - puck.r <= table.wall) {
                    if (inMouth) { onGoal("you"); return; }
                    puck.y = table.wall + puck.r;
                    puck.vy = Math.abs(puck.vy) * 0.985;
                    sfx.wall(); vibrate(6);
                }
                if (puck.y + puck.r >= h - table.wall) {
                    if (inMouth) { onGoal("ai"); return; }
                    puck.y = (h - table.wall) - puck.r;
                    puck.vy = -Math.abs(puck.vy) * 0.985;
                    sfx.wall(); vibrate(6);
                }

                if (puck.x - puck.r <= table.wall) {
                    puck.x = table.wall + puck.r;
                    puck.vx = Math.abs(puck.vx) * 0.985;
                    sfx.wall(); vibrate(6);
                }
                if (puck.x + puck.r >= w - table.wall) {
                    puck.x = (w - table.wall) - puck.r;
                    puck.vx = -Math.abs(puck.vx) * 0.985;
                    sfx.wall(); vibrate(6);
                }
            }

            function onGoal(who) {
                sfx.goal();
                vibrate([18, 24, 18]);

                if (who === "you") state.scoreYou++;
                else state.scoreAI++;

                ui.sYou.textContent = String(state.scoreYou);
                ui.sAI.textContent = String(state.scoreAI);

                if (state.scoreYou >= GAME.targetScore || state.scoreAI >= GAME.targetScore) {
                    state.paused = true;
                    state.gameOver = true;
                    state.message = (state.scoreYou > state.scoreAI) ? "You win! Press Reset" : "AI wins! Press Reset";
                    sfx.win();
                    vibrate([30, 40, 30, 40, 30]);
                    puck.vx = puck.vy = 0;
                    return;
                }

                resetPositions();
                state.paused = true;
                state.message = (who === "you") ? "Goal! Tap to serve" : "AI scored. Tap to serve";
            }

            function movePad(pad, target, dt, speed, half) {
                const { w, h } = dims();
                const mid = h / 2;

                let tx = clamp(target.x, table.pad, w - table.pad);
                let ty = target.y;
                if (half === "bottom") ty = clamp(ty, mid + table.pad, h - table.pad);
                else ty = clamp(ty, table.pad, mid - table.pad);

                const dx = tx - pad.x, dy = ty - pad.y;
                const dist = Math.hypot(dx, dy);

                if (dist > 0.001) {
                    const step = Math.min(speed * dt, dist);
                    const nx = dx / dist, ny = dy / dist;
                    const nxp = pad.x + nx * step;
                    const nyp = pad.y + ny * step;
                    pad.vx = (nxp - pad.x) / dt;
                    pad.vy = (nyp - pad.y) / dt;
                    pad.x = nxp; pad.y = nyp;
                } else {
                    pad.vx *= 0.45; pad.vy *= 0.45;
                }
            }

            // ---------------- AI prediction & shot logic ----------------
            function predictPuckXAtY(targetY) {
                const { w } = dims();
                const left = table.wall + puck.r;
                const right = (w - table.wall) - puck.r;

                let x = puck.x, y = puck.y, vx = puck.vx, vy = puck.vy;
                if (Math.abs(vy) < 15) return x;

                for (let i = 0; i < 160; i++) {
                    const dt = 1 / 240;
                    x += vx * dt; y += vy * dt;
                    if (x <= left) { x = left + (left - x); vx = Math.abs(vx); }
                    if (x >= right) { x = right - (x - right); vx = -Math.abs(vx); }
                    if ((vy < 0 && y <= targetY) || (vy > 0 && y >= targetY)) return x;
                }
                return x;
            }

            function reflectXForBank(targetX) {
                const { w } = dims();
                const left = table.wall + puck.r;
                const right = (w - table.wall) - puck.r;
                const goLeft = puck.x > w / 2;
                return goLeft ? (left - (targetX - left)) : (right + (right - targetX));
            }

            function legendaryCounterCorner(goalLeftX, goalRightX) {
                if (profile.samples < 10) return (puck.x > (goalLeftX + goalRightX) / 2) ? goalLeftX : goalRightX;
                if (profile.emaShotDir > 0.12) return goalLeftX;
                if (profile.emaShotDir < -0.12) return goalRightX;
                return (puck.x > (goalLeftX + goalRightX) / 2) ? goalLeftX : goalRightX;
            }

            function computeAiTarget() {
                const { w, h } = dims();
                const midY = h / 2;
                const P = effectiveAIParams();

                let interceptY = h * 0.26;
                interceptY *= clamp(P.goalieSnap, 0.9, 1.25);

                const puckInAiHalf = (puck.y < midY);
                const puckComingUp = (puck.vy < -40);

                if (puckComingUp || puckInAiHalf) {
                    const px = predictPuckXAtY(interceptY);
                    return { x: clamp(px, table.pad, w - table.pad), y: clamp(interceptY, table.pad, midY - table.pad), speed: P.speed };
                }

                const pressureY = clamp(h * (0.26 + 0.18 * P.pressure), table.pad, midY - table.pad);
                return { x: clamp(puck.x, table.pad, w - table.pad), y: pressureY, speed: P.speed };
            }

            function aiShotAssist() {
                const { w, h } = dims();
                const P = effectiveAIParams();

                const dx = puck.x - ai.x, dy = puck.y - ai.y;
                const dist = Math.hypot(dx, dy);
                if (dist > 145) return null;

                const goalW = w * table.goalWidthFrac;
                const gx1 = (w - goalW) / 2;
                const gx2 = (w + goalW) / 2;

                const targetCorner = (state.diff === "legendary")
                    ? legendaryCounterCorner(gx1 + 12, gx2 - 12)
                    : (puck.x > w / 2 ? (gx1 + 12) : (gx2 - 12));

                const offCenter = Math.abs(puck.x - w / 2) / (w / 2);
                const bankChance = clamp(P.bankBias * (0.35 + offCenter), 0, 0.95);
                const useBank = (Math.random() < bankChance) && (offCenter > 0.15);

                let aimX = targetCorner;
                if (state.persona === "trickshot" && Math.random() < P.trickRate) {
                    aimX = (puck.x > w / 2) ? (gx2 - 10) : (gx1 + 10);
                }

                const aimY = h - table.wall - 6;
                const finalAimX = useBank ? reflectXForBank(aimX) : aimX;

                const vx = finalAimX - puck.x;
                const vy = aimY - puck.y;
                const L = Math.hypot(vx, vy) || 1;
                const backoff = 28 * (0.9 + 0.2 * P.shotPower);

                const tx = puck.x - (vx / L) * backoff;
                const ty = puck.y - (vy / L) * backoff;

                const midY = h / 2;
                return { x: clamp(tx, table.pad, w - table.pad), y: clamp(ty, table.pad, midY - table.pad) };
            }

            // Learning update when YOU hit
            function updateLearningOnHit() {
                const base = baseParamsByDifficulty(state.diff);
                const learnRate = base.learn;
                if (learnRate <= 0) return;

                // emaShotDir uses puck.vx sign after your hit
                const dir = clamp(puck.vx / (Math.abs(puck.vx) + 250), -1, 1);
                const a = learnRate;

                profile.samples = (profile.samples || 0) + 1;
                profile.emaShotDir = profile.emaShotDir + a * (dir - profile.emaShotDir);
                profile.lastUpdate = Date.now();

                if (profile.samples % 5 === 0) saveProfile(profile);
                updateProfileUI();
            }

            // ---------------- Update loop ----------------
            function step(dt) {
                const { w, h } = dims();
                const mid = h / 2;

                // Player target driven by thumbpad vector
                // Move speed scales with screen size so it feels consistent on Android
                const padSpeed = Math.max(900, Math.min(1500, w * 1.3));
                you.vx *= 0.65; you.vy *= 0.65;

                // Apply thumb vector as a "desired velocity"
                const vx = state.joyVec.x * padSpeed;
                const vy = state.joyVec.y * padSpeed;

                // Integrate paddle position from joystick (keeps finger off the paddle)
                you.x += vx * dt;
                you.y += vy * dt;

                // Clamp bottom half
                you.x = clamp(you.x, table.pad, w - table.pad);
                you.y = clamp(you.y, mid + table.pad, h - table.pad);

                // compute paddle velocity (for collisions)
                you.vx = vx;
                you.vy = vy;

                // AI
                const P = effectiveAIParams();
                const base = computeAiTarget();
                const shot = aiShotAssist();
                const aTarget = shot || { x: base.x, y: base.y };
                movePad(ai, aTarget, dt, P.speed, "top");

                // particles
                for (let i = sparks.length - 1; i >= 0; i--) {
                    const s = sparks[i];
                    s.life -= dt;
                    s.x += s.vx * dt;
                    s.y += s.vy * dt;
                    s.vx *= Math.exp(-5.5 * dt);
                    s.vy *= Math.exp(-5.5 * dt);
                    if (s.life <= 0) sparks.splice(i, 1);
                }
                puck.glow *= Math.exp(-6.5 * dt);

                if (state.paused || state.gameOver || !state.running) return;

                // puck integrate
                state.lastPuckV.vx = puck.vx;
                state.lastPuckV.vy = puck.vy;

                puck.x += puck.vx * dt;
                puck.y += puck.vy * dt;

                // friction
                const fr = Math.exp(-0.66 * dt);
                puck.vx *= fr; puck.vy *= fr;

                // clamp speed
                const sp = Math.hypot(puck.vx, puck.vy);
                if (sp > puck.max) {
                    const k = puck.max / sp;
                    puck.vx *= k; puck.vy *= k;
                }

                // collisions
                const hitYou = collideDiscSafe(you);
                if (hitYou) {
                    const dv = Math.hypot(puck.vx - state.lastPuckV.vx, puck.vy - state.lastPuckV.vy);
                    if (dv > 60) updateLearningOnHit();
                }
                collideDiscSafe(ai);

                // walls/goals
                puckWallsGoals();

                // prevent dead puck
                if (Math.hypot(puck.vx, puck.vy) < 18) {
                    puck.vx += (Math.random() * 2 - 1) * 10;
                    puck.vy += (Math.random() * 2 - 1) * 10;
                }
            }

            // ---------------- Drawing (neon board) ----------------
            function draw() {
                const { w, h } = dims();
                const mid = h / 2;

                // background
                ctx.fillStyle = "#070b12";
                ctx.fillRect(0, 0, w, h);

                // table gradient
                const g = ctx.createLinearGradient(0, 0, 0, h);
                g.addColorStop(0, "#0c1a2a");
                g.addColorStop(0.55, "#0b2036");
                g.addColorStop(1, "#071522");
                ctx.fillStyle = g;
                ctx.fillRect(0, 0, w, h);

                // rail glow
                drawRailGlow(w, h);

                // walls
                ctx.fillStyle = "rgba(255,255,255,.10)";
                ctx.fillRect(0, 0, w, table.wall);
                ctx.fillRect(0, h - table.wall, w, table.wall);
                ctx.fillRect(0, 0, table.wall, h);
                ctx.fillRect(w - table.wall, 0, table.wall, h);

                // goals
                const goalW = w * table.goalWidthFrac;
                const gx1 = (w - goalW) / 2;
                ctx.fillStyle = "rgba(0,0,0,.35)";
                ctx.fillRect(gx1, 0, goalW, table.wall);
                ctx.fillRect(gx1, h - table.wall, goalW, table.wall);

                // center line and circle
                ctx.strokeStyle = "rgba(233,240,255,.25)";
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(0, mid); ctx.lineTo(w, mid); ctx.stroke();
                ctx.beginPath(); ctx.arc(w / 2, mid, 62, 0, Math.PI * 2); ctx.stroke();

                // paddles + puck + sparks
                drawPaddle(ai, "#e9f0ff", "#0b0f14", "AI");
                drawPaddle(you, "#ffd66e", "#0b0f14", "YOU");

                // sparks
                for (const s of sparks) {
                    const a = clamp(s.life / 0.35, 0, 1);
                    ctx.globalAlpha = a;
                    ctx.fillStyle = "rgba(255,214,110,.9)";
                    ctx.fillRect(s.x, s.y, 2, 2);
                }
                ctx.globalAlpha = 1;

                drawPuck();

                // message
                if (state.running && state.message) {
                    ctx.save();
                    ctx.fillStyle = "rgba(0,0,0,.55)";
                    ctx.fillRect(0, mid - 36, w, 72);
                    ctx.fillStyle = "#e9f0ff";
                    ctx.font = "980 18px system-ui,-apple-system,Segoe UI,Roboto,sans-serif";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(state.message, w / 2, mid);
                    ctx.restore();
                }
            }

            function drawRailGlow(w, h) {
                const gl = ctx.createLinearGradient(0, 0, 0, h);
                gl.addColorStop(0, "rgba(42,165,255,.22)");
                gl.addColorStop(0.5, "rgba(42,165,255,.08)");
                gl.addColorStop(1, "rgba(42,165,255,.22)");
                ctx.fillStyle = gl;
                ctx.fillRect(0, 0, 14, h);

                const gr = ctx.createLinearGradient(0, 0, 0, h);
                gr.addColorStop(0, "rgba(255,75,110,.22)");
                gr.addColorStop(0.5, "rgba(255,75,110,.08)");
                gr.addColorStop(1, "rgba(255,75,110,.22)");
                ctx.fillStyle = gr;
                ctx.fillRect(w - 14, 0, 14, h);
            }

            function drawPaddle(p, main, inner, label) {
                ctx.save();
                ctx.globalAlpha = 0.25;
                ctx.fillStyle = "#000";
                ctx.beginPath(); ctx.arc(p.x, p.y + 3, p.r, 0, Math.PI * 2); ctx.fill();
                ctx.restore();

                ctx.fillStyle = main;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2); ctx.fill();

                ctx.fillStyle = inner;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.r * 0.46, 0, Math.PI * 2); ctx.fill();

                ctx.globalAlpha = 0.18;
                ctx.fillStyle = "#fff";
                ctx.beginPath(); ctx.arc(p.x - p.r * 0.25, p.y - p.r * 0.25, p.r * 0.35, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;

                ctx.save();
                ctx.fillStyle = "rgba(0,0,0,.50)";
                ctx.font = "900 10px system-ui,-apple-system,Segoe UI,Roboto,sans-serif";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(label, p.x, p.y);
                ctx.restore();
            }

            function drawPuck() {
                if (puck.glow > 0.02) {
                    ctx.save();
                    ctx.globalAlpha = 0.35 * puck.glow;
                    const rg = ctx.createRadialGradient(puck.x, puck.y, 2, puck.x, puck.y, 34);
                    rg.addColorStop(0, "rgba(255,214,110,1)");
                    rg.addColorStop(1, "rgba(255,214,110,0)");
                    ctx.fillStyle = rg;
                    ctx.beginPath(); ctx.arc(puck.x, puck.y, 34, 0, Math.PI * 2); ctx.fill();
                    ctx.restore();
                }

                ctx.save();
                ctx.globalAlpha = 0.22;
                ctx.fillStyle = "#000";
                ctx.beginPath(); ctx.arc(puck.x, puck.y + 3, puck.r, 0, Math.PI * 2); ctx.fill();

                ctx.globalAlpha = 1;
                ctx.fillStyle = "#0b0f14";
                ctx.beginPath(); ctx.arc(puck.x, puck.y, puck.r, 0, Math.PI * 2); ctx.fill();

                ctx.globalAlpha = 0.22;
                ctx.fillStyle = "#e9f0ff";
                ctx.beginPath(); ctx.arc(puck.x - 3, puck.y - 3, puck.r * 0.55, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            }

            // ---------------- Main loop ----------------
            function loop(now) {
                const frameDt = Math.min(GAME.maxFrame, (now - state.last) / 1000);
                state.last = now;
                state.acc += frameDt;

                while (state.acc >= GAME.fixedDt) {
                    step(GAME.fixedDt);
                    state.acc -= GAME.fixedDt;
                }

                draw();
                requestAnimationFrame(loop);
            }

            // ---------------- Start ----------------
            resetPositions();
            requestAnimationFrame(loop);

        })();
    </script>
</body>

</html>