<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <meta name="theme-color" content="#070b12" />
    <link rel="manifest" href="manifest.webmanifest" />
    <title>Air Hockey Pro</title>

    <style>
        :root {
            --bg: #070b12;
            --panel: rgba(18, 26, 36, .82);
            --panel2: rgba(18, 26, 36, .62);
            --line: rgba(255, 255, 255, .12);
            --text: #e9f0ff;
            --muted: #a9b6cc;
            --gold: #ffd66e;
            --ice: #cfe6ff;
            --blue: #2aa5ff;
            --shadow: 0 18px 60px rgba(0, 0, 0, .45);
            --radius: 16px;

            /* "Board diameter" – smallest viewport dimension */
            --board: min(100vw, 100vh);
            --uiMax: min(calc(var(--board) - 20px), 560px);
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
            overflow: hidden;
            touch-action: none;
            -webkit-text-size-adjust: 100%;
        }

        .vh {
            height: 100vh;
        }

        @supports (height: 100dvh) {
            .vh {
                height: 100dvh;
            }

            :root {
                --board: min(100vw, 100dvh);
            }
        }

        #wrap {
            position: fixed;
            inset: 0;
        }

        canvas {
            width: 100vw;
            height: 100%;
            display: block;
            background: var(--bg);
            touch-action: none;
        }

        /* ===== TOP BAR (constrained inside board diameter) ===== */
        .topbar {
            position: fixed;
            top: env(safe-area-inset-top, 0px);
            left: 50%;
            transform: translateX(-50%);
            width: var(--uiMax);
            padding: 10px 10px 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            z-index: 10;
            pointer-events: none;
            gap: 10px;
            box-sizing: border-box;
        }

        .rightBtns {
            display: flex;
            gap: 8px;
            align-items: center;
            pointer-events: auto;
        }

        .btn {
            background: rgba(18, 26, 36, .65);
            border: 1px solid rgba(255, 255, 255, .14);
            color: var(--text);
            padding: 10px 12px;
            border-radius: 12px;
            font-weight: 950;
            user-select: none;
            cursor: pointer;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 22px rgba(0, 0, 0, .18);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn:active {
            transform: translateY(1px);
        }

        .btn.small {
            padding: 9px 12px;
            font-size: 13px;
        }

        .btn.primary {
            border-color: rgba(255, 214, 110, .30);
            background: rgba(255, 214, 110, .14);
        }

        /* Mobile-clear scoreboard */
        .scorebar {
            pointer-events: none;
            flex: 1 1 auto;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            min-width: 0;
        }

        .scorePill {
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 9px 12px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, .12);
            background: rgba(18, 26, 36, .55);
            backdrop-filter: blur(10px);
            box-shadow: 0 14px 30px rgba(0, 0, 0, .22);
            max-width: 100%;
            overflow: hidden;
        }

        .scoreNums {
            display: flex;
            align-items: baseline;
            gap: 10px;
            font-weight: 1000;
            letter-spacing: .2px;
            white-space: nowrap;
            min-width: 0;
        }

        .scoreNums .side {
            display: flex;
            flex-direction: column;
            line-height: 1.05;
        }

        .scoreNums .label {
            font-size: 10px;
            font-weight: 900;
            letter-spacing: .7px;
            color: rgba(233, 240, 255, .78);
            text-transform: uppercase;
        }

        .scoreNums .num {
            font-size: 18px;
            font-weight: 1000;
            text-shadow:
                0 0 8px rgba(42, 165, 255, .22),
                0 0 18px rgba(255, 214, 110, .10);
        }

        .scoreNums .sep {
            opacity: .55;
            font-size: 16px;
            padding: 0 2px;
        }

        /* ===== BOTTOM SHEET MENU (constrained inside board diameter) ===== */
        .backdrop {
            position: fixed;
            inset: 0;
            z-index: 20;
            background: rgba(0, 0, 0, .55);
            backdrop-filter: blur(5px);
            opacity: 0;
            pointer-events: none;
            transition: opacity .18s ease;
        }

        .backdrop.open {
            opacity: 1;
            pointer-events: auto;
        }

        .sheet {
            position: fixed;
            left: 50%;
            transform: translateX(-50%) translateY(110%);
            bottom: 0;
            z-index: 21;
            width: var(--uiMax);
            padding-bottom: env(safe-area-inset-bottom, 0px);
            pointer-events: none;
            transition: transform .22s ease;
            box-sizing: border-box;
            will-change: transform;
        }

        .sheet.open {
            transform: translateX(-50%) translateY(0%);
            pointer-events: auto;
        }

        .sheetCard {
            margin: 0 10px 10px;
            border-radius: 20px;
            background: rgba(18, 26, 36, .92);
            border: 1px solid rgba(255, 255, 255, .12);
            box-shadow: var(--shadow);
            overflow: hidden;
            user-select: none;
            touch-action: none;
        }

        .grabWrap {
            padding: 10px 14px 10px;
            background: rgba(255, 255, 255, .04);
            border-bottom: 1px solid rgba(255, 255, 255, .10);
            cursor: grab;
            touch-action: none;
        }

        .grabBar {
            width: 44px;
            height: 4px;
            border-radius: 999px;
            background: rgba(255, 255, 255, .22);
            margin: 0 auto;
        }

        .sheetHeader {
            padding: 10px 14px 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            background: rgba(255, 255, 255, .02);
        }

        .sheetTitle {
            margin: 0;
            font-size: 14px;
            font-weight: 1000;
            letter-spacing: .3px;
        }

        .sheetBody {
            padding: 12px 14px 14px;
        }

        .row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .row.tight {
            gap: 8px;
        }

        .spacer {
            height: 10px;
        }

        select,
        label.chk {
            background: rgba(255, 255, 255, .08);
            border: 1px solid rgba(255, 255, 255, .14);
            color: var(--text);
            padding: 10px 10px;
            border-radius: 12px;
            font-weight: 950;
            outline: none;
            flex: 1 1 200px;
            min-width: 160px;
        }

        label.chk {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            flex: 1 1 180px;
            user-select: none;
        }

        label.chk input {
            accent-color: var(--gold);
        }

        .stat {
            border: 1px solid rgba(255, 255, 255, .10);
            background: rgba(0, 0, 0, .18);
            border-radius: 14px;
            padding: 10px 12px;
            font-weight: 950;
            flex: 1 1 220px;
        }

        .stat small {
            display: block;
            color: var(--muted);
            font-weight: 800;
            margin-bottom: 6px;
        }

        .hide {
            display: none !important;
        }

        @media (max-width: 420px) {
            .scorePill {
                padding: 8px 10px;
                gap: 8px;
            }

            .scoreNums .num {
                font-size: 18px;
            }

            select,
            label.chk {
                min-width: 140px;
            }

            .btn.small {
                padding: 9px 12px;
            }

            .sheetCard {
                margin: 0 6px 8px;
            }
        }
    </style>
</head>

<body>
    <div id="wrap" class="vh">
        <canvas id="c"></canvas>
    </div>

    <!-- Topbar -->
    <div class="topbar">
        <div class="scorebar">
            <div class="scorePill" aria-live="polite">
                <div class="scoreNums">
                    <div class="side">
                        <div class="label">Player</div>
                        <div class="num" id="sYou">0</div>
                    </div>
                    <div class="sep">VS</div>
                    <div class="side">
                        <div class="label">AI</div>
                        <div class="num" id="sAI">0</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="rightBtns">
            <button class="btn small" id="menuBtn">Menu</button>
        </div>
    </div>

    <!-- Backdrop + bottom sheet menu -->
    <div class="backdrop" id="backdrop"></div>

    <div class="sheet" id="sheet">
        <div class="sheetCard" id="sheetCard">
            <!-- swipe area -->
            <div class="grabWrap" id="grabWrap" aria-label="Drag down to close">
                <div class="grabBar"></div>
            </div>

            <div class="sheetHeader">
                <h2 class="sheetTitle">Menu</h2>
                <button class="btn small" id="closeSheetBtn">Close</button>
            </div>

            <div class="sheetBody">
                <div class="row">
                    <button class="btn primary" id="startResumeBtn" style="flex:1 1 220px;">Start / Resume</button>
                    <button class="btn" id="resetMatchBtn" style="flex:1 1 180px;">Reset Match</button>
                </div>

                <div class="spacer"></div>

                <div class="row">
                    <select id="diffSel">
                        <option value="easy">Easy</option>
                        <option value="normal" selected>Normal</option>
                        <option value="smart">Smart</option>
                        <option value="hard">Hard</option>
                        <option value="pro">Pro</option>
                        <option value="legendary">Legendary (Learns you)</option>
                    </select>

                    <select id="personaSel">
                        <option value="defensive" selected>AI: Defensive</option>
                        <option value="aggressive">AI: Aggressive</option>
                        <option value="trickshot">AI: Trickshot</option>
                    </select>
                </div>

                <div class="spacer"></div>

                <div class="row tight">
                    <label class="chk">
                        <input type="checkbox" id="soundToggle" checked />
                        Sound
                    </label>
                    <label class="chk">
                        <input type="checkbox" id="hapticsToggle" checked />
                        Haptics (Android)
                    </label>
                </div>

                <div class="spacer"></div>

                <div class="row">
                    <div class="stat">
                        <small>Legendary profile</small>
                        <div id="profileLine">Collecting data…</div>
                    </div>
                    <div class="stat">
                        <small>Target</small>
                        <div>First to <span id="targetLabel">7</span></div>
                    </div>
                </div>

                <div class="spacer"></div>

                <div class="row">
                    <button class="btn" id="resetLearningBtn" style="flex:1 1 220px;">Reset AI Learning</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        (() => {
            // SW
            if ("serviceWorker" in navigator) {
                window.addEventListener("load", async () => {
                    try { await navigator.serviceWorker.register("./sw.js"); } catch { }
                });

                // reload once when new SW takes control (keeps updates smooth)
                navigator.serviceWorker.addEventListener("controllerchange", () => {
                    location.reload();
                });
            }

            const canvas = document.getElementById("c");
            const ctx = canvas.getContext("2d", { alpha: false });

            const ui = {
                sYou: document.getElementById("sYou"),
                sAI: document.getElementById("sAI"),

                menuBtn: document.getElementById("menuBtn"),
                backdrop: document.getElementById("backdrop"),
                sheet: document.getElementById("sheet"),
                sheetCard: document.getElementById("sheetCard"),
                grabWrap: document.getElementById("grabWrap"),
                closeSheetBtn: document.getElementById("closeSheetBtn"),

                startResumeBtn: document.getElementById("startResumeBtn"),
                resetMatchBtn: document.getElementById("resetMatchBtn"),

                diffSel: document.getElementById("diffSel"),
                personaSel: document.getElementById("personaSel"),
                soundToggle: document.getElementById("soundToggle"),
                hapticsToggle: document.getElementById("hapticsToggle"),
                resetLearningBtn: document.getElementById("resetLearningBtn"),

                profileLine: document.getElementById("profileLine"),
                targetLabel: document.getElementById("targetLabel"),
            };

            function resize() {
                const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
                canvas.width = Math.floor(innerWidth * dpr);
                canvas.height = Math.floor(innerHeight * dpr);
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            }
            addEventListener("resize", resize, { passive: true });
            resize();

            const dims = () => ({ w: innerWidth, h: innerHeight });
            const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

            // Haptics
            function vibrate(pattern) {
                if (!ui.hapticsToggle.checked) return;
                if (!("vibrate" in navigator)) return;
                try { navigator.vibrate(pattern); } catch { }
            }

            // Audio (generated)
            let audioCtx = null;
            function ensureAudio() {
                if (!ui.soundToggle.checked) return;
                if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                if (audioCtx.state === "suspended") audioCtx.resume().catch(() => { });
            }
            function beep(type, freq, dur, gain) {
                if (!ui.soundToggle.checked) return;
                ensureAudio();
                if (!audioCtx) return;
                const t0 = audioCtx.currentTime;
                const o = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                o.type = type;
                o.frequency.setValueAtTime(freq, t0);
                g.gain.setValueAtTime(0.0001, t0);
                g.gain.exponentialRampToValueAtTime(Math.max(0.0002, gain), t0 + 0.01);
                g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
                o.connect(g).connect(audioCtx.destination);
                o.start(t0);
                o.stop(t0 + dur + 0.02);
            }
            const sfx = {
                hit: (k) => beep("triangle", 140 + 140 * k, 0.07, 0.07 + 0.18 * k),
                wall: () => beep("sine", 720, 0.06, 0.06),
                goal: () => {
                    beep("square", 520, 0.10, 0.10);
                    setTimeout(() => beep("square", 780, 0.10, 0.09), 90);
                    setTimeout(() => beep("square", 1040, 0.12, 0.08), 180);
                },
                win: () => {
                    beep("sawtooth", 440, 0.14, 0.10);
                    setTimeout(() => beep("sawtooth", 660, 0.14, 0.09), 140);
                    setTimeout(() => beep("sawtooth", 880, 0.18, 0.08), 280);
                }
            };
            window.addEventListener("pointerdown", ensureAudio, { passive: true });

            // Game constants
            const GAME = { targetScore: 7, fixedDt: 1 / 120, maxFrame: 1 / 30 };
            const table = { wall: 10, pad: 22, goalWidthFrac: 0.34 };
            ui.targetLabel.textContent = String(GAME.targetScore);

            // Entities
            const puck = { x: 0, y: 0, r: 10, vx: 0, vy: 0, max: 1600, glow: 0 };
            const you = { x: 0, y: 0, r: 22, vx: 0, vy: 0 };
            const ai = { x: 0, y: 0, r: 22, vx: 0, vy: 0 };

            // Particles
            const sparks = [];
            function addSparks(x, y, n, strength) {
                for (let i = 0; i < n; i++) {
                    sparks.push({
                        x, y,
                        vx: (Math.random() * 2 - 1) * (120 + 260 * strength),
                        vy: (Math.random() * 2 - 1) * (120 + 260 * strength),
                        life: 0.18 + Math.random() * 0.22
                    });
                }
            }

            // Learning profile
            const PROFILE_KEY = "ah_profile_v5";
            function makeFreshProfile() { return { samples: 0, emaShotDir: 0, lastUpdate: Date.now() }; }
            function loadProfile() { try { const r = localStorage.getItem(PROFILE_KEY); return r ? JSON.parse(r) : null; } catch { return null; } }
            function saveProfile(p) { try { localStorage.setItem(PROFILE_KEY, JSON.stringify(p)); } catch { } }
            let profile = loadProfile() || makeFreshProfile();

            function updateProfileUI() {
                if (!profile || profile.samples < 10) {
                    ui.profileLine.textContent = "Collecting data…";
                    return;
                }
                const bias = profile.emaShotDir < -0.15 ? "Left bias" : (profile.emaShotDir > 0.15 ? "Right bias" : "Balanced");
                ui.profileLine.textContent = `${profile.samples} hits • ${bias}`;
            }
            updateProfileUI();

            // State
            const state = {
                running: false,
                paused: true,
                gameOver: false,

                scoreYou: 0,
                scoreAI: 0,
                diff: ui.diffSel.value,
                persona: ui.personaSel.value,

                last: performance.now(),
                acc: 0,

                pointerDown: false,
                youTarget: { x: 0, y: 0 },
                lastPuckV: { vx: 0, vy: 0 },

                toastText: "",
                toastT: 0,
            };

            function showToast(text, seconds = 1.2) {
                state.toastText = text;
                state.toastT = seconds;
            }

            // Difficulty + personality
            function baseParamsByDifficulty(d) {
                switch (d) {
                    case "easy": return { speed: 1020, pressure: 0.30, predict: 0.40, shotPower: 0.65, adapt: 0.08, learn: 0.00 };
                    case "normal": return { speed: 1250, pressure: 0.48, predict: 0.58, shotPower: 0.78, adapt: 0.12, learn: 0.00 };
                    case "smart": return { speed: 1400, pressure: 0.60, predict: 0.70, shotPower: 0.86, adapt: 0.16, learn: 0.06 };
                    case "hard": return { speed: 1560, pressure: 0.72, predict: 0.82, shotPower: 0.92, adapt: 0.20, learn: 0.08 };
                    case "pro": return { speed: 1720, pressure: 0.82, predict: 0.90, shotPower: 0.96, adapt: 0.24, learn: 0.10 };
                    case "legendary": return { speed: 1880, pressure: 0.90, predict: 0.95, shotPower: 0.99, adapt: 0.30, learn: 0.22 };
                    default: return { speed: 1250, pressure: 0.48, predict: 0.58, shotPower: 0.78, adapt: 0.12, learn: 0.00 };
                }
            }
            function personaModifiers(persona) {
                switch (persona) {
                    case "defensive": return { pressureMul: 0.85, bankBias: 0.40, goalieSnap: 1.15, trickRate: 0.10 };
                    case "aggressive": return { pressureMul: 1.20, bankBias: 0.55, goalieSnap: 0.95, trickRate: 0.12 };
                    case "trickshot": return { pressureMul: 1.05, bankBias: 0.85, goalieSnap: 1.00, trickRate: 0.32 };
                    default: return { pressureMul: 1.00, bankBias: 0.55, goalieSnap: 1.00, trickRate: 0.12 };
                }
            }
            function effectiveAIParams() {
                const base = baseParamsByDifficulty(state.diff);
                const pm = personaModifiers(state.persona);

                const diffScore = (state.scoreYou - state.scoreAI);
                const boost = clamp(diffScore * base.adapt, -0.18, 0.40);

                let learnBoost = 0;
                if (state.diff === "legendary") learnBoost = clamp(profile.samples / 250, 0, 0.25);

                return {
                    speed: base.speed * (1 + boost + learnBoost * 0.30),
                    pressure: clamp(base.pressure * pm.pressureMul + boost * 0.8 + learnBoost * 0.25, 0.25, 0.98),
                    predict: clamp(base.predict + boost * 0.6 + learnBoost * 0.25, 0.35, 0.99),
                    shotPower: clamp(base.shotPower + boost * 0.25 + learnBoost * 0.20, 0.60, 1.0),
                    bankBias: pm.bankBias,
                    goalieSnap: pm.goalieSnap,
                    trickRate: pm.trickRate,
                    learn: base.learn
                };
            }

            // Player controls
            function setTargetFromEvent(e) {
                state.youTarget.x = e.clientX;
                state.youTarget.y = e.clientY;
            }
            canvas.addEventListener("pointerdown", (e) => {
                state.pointerDown = true;
                setTargetFromEvent(e);

                // tap to serve (only if sheet is closed)
                if (state.running && state.paused && !state.gameOver && !ui.sheet.classList.contains("open")) serve();
            }, { passive: true });

            canvas.addEventListener("pointermove", (e) => {
                if (!state.pointerDown) return;
                setTargetFromEvent(e);
            }, { passive: true });

            canvas.addEventListener("pointerup", () => state.pointerDown = false, { passive: true });
            canvas.addEventListener("pointercancel", () => state.pointerDown = false, { passive: true });

            // ===== Bottom sheet: velocity flick + momentum + rubber band + fling anywhere =====
            const RUBBER_MAX_UP = 70;   // visual max overscroll up
            const CLOSE_DIST = 90;      // px
            const FLICK_V = 1.10;       // px/ms
            const FLICK_MIN_DY = 18;    // px even small flick closes

            let sheetDrag = {
                active: false,
                id: null,
                startY: 0,
                dy: 0,
                lastY: 0,
                lastT: 0,
                vy: 0,
                raf: 0
            };

            function rubberBand(upDy) {
                // upDy is negative. Apply soft resistance.
                const a = Math.min(RUBBER_MAX_UP, Math.sqrt(Math.max(0, -upDy)) * 9);
                return -a;
            }

            function isInteractive(el) {
                if (!el) return false;
                return !!el.closest("button, a, input, select, textarea, label, option");
            }

            function sheetSetY(px) {
                ui.sheet.style.transform = `translateX(-50%) translateY(${px}px)`;
            }

            function sheetSnapOpen() {
                ui.sheet.style.transition = "";
                ui.sheet.classList.add("open");
                ui.backdrop.classList.add("open");
                ui.sheet.style.transform = "translateX(-50%) translateY(0%)";
            }

            function openSheet() {
                state.paused = true;
                ui.backdrop.classList.add("open");
                ui.sheet.classList.add("open");
                ui.sheet.style.transition = "";
                ui.sheet.style.transform = "translateX(-50%) translateY(0%)";
            }

            function stopSheetAnim() {
                if (sheetDrag.raf) cancelAnimationFrame(sheetDrag.raf);
                sheetDrag.raf = 0;
            }

            function closeSheet() {
                stopSheetAnim();
                ui.backdrop.classList.remove("open");
                ui.sheet.classList.remove("open");
                ui.sheet.style.transition = "";
                ui.sheet.style.transform = "";
                sheetDrag.active = false;
                sheetDrag.id = null;
                sheetDrag.dy = 0;
                sheetDrag.vy = 0;
            }

            ui.menuBtn.addEventListener("click", openSheet);
            ui.closeSheetBtn.addEventListener("click", closeSheet);
            ui.backdrop.addEventListener("click", closeSheet);

            function beginSheetDrag(e) {
                stopSheetAnim();
                ui.sheet.style.transition = "none";

                sheetDrag.active = true;
                sheetDrag.id = e.pointerId;
                sheetDrag.startY = e.clientY;
                sheetDrag.lastY = e.clientY;
                sheetDrag.lastT = performance.now();
                sheetDrag.dy = 0;
                sheetDrag.vy = 0;

                // capture on the actual element receiving pointerdown
                try { e.currentTarget.setPointerCapture(e.pointerId); } catch { }
            }

            function moveSheetDrag(e) {
                if (!sheetDrag.active || e.pointerId !== sheetDrag.id) return;

                const now = performance.now();
                const dt = Math.max(1, now - sheetDrag.lastT);
                const dyStep = e.clientY - sheetDrag.lastY;
                sheetDrag.vy = dyStep / dt; // px/ms, down positive
                sheetDrag.lastY = e.clientY;
                sheetDrag.lastT = now;

                const rawDy = e.clientY - sheetDrag.startY;

                let dy = rawDy;
                if (dy < 0) dy = rubberBand(dy);

                sheetDrag.dy = dy;
                sheetSetY(dy);
            }

            function momentumOrSnap() {
                // Decide close vs momentum vs snap-back
                const dy = sheetDrag.dy;
                const v0 = sheetDrag.vy;

                const flickDown = v0 > FLICK_V;
                const movedEnough = dy > CLOSE_DIST;
                const flickClose = flickDown && dy > FLICK_MIN_DY;

                if (movedEnough || flickClose) {
                    closeSheet();
                    return;
                }

                // If dragged upward (overscroll), just snap back open
                if (dy < 0) {
                    ui.sheet.style.transition = "";
                    sheetSnapOpen();
                    return;
                }

                // Momentum if released with some downward velocity
                if (dy > 0 && v0 > 0.20) {
                    const t0 = performance.now();
                    let y = dy;
                    let v = v0;           // px/ms
                    const friction = 0.006; // velocity decay per ms (tuned)

                    const tick = (t) => {
                        const dt = Math.min(34, t - t0); // guard
                        // integrate with actual dt between frames
                    };

                    let last = performance.now();
                    const frame = (now) => {
                        const dtMs = Math.min(34, now - last);
                        last = now;

                        // exponential-ish damping
                        v = v * Math.exp(-friction * dtMs);

                        y += v * dtMs;

                        // cap downward travel so it doesn't go crazy
                        y = Math.min(y, 240);

                        // If it crosses close threshold while coasting -> close
                        if (y > CLOSE_DIST + 18 && v > 0.25) {
                            closeSheet();
                            return;
                        }

                        // if velocity dies, snap back
                        if (v < 0.06) {
                            ui.sheet.style.transition = "";
                            sheetSnapOpen();
                            return;
                        }

                        sheetSetY(y);
                        sheetDrag.raf = requestAnimationFrame(frame);
                    };

                    sheetDrag.raf = requestAnimationFrame(frame);
                    return;
                }

                // Default snap back open
                ui.sheet.style.transition = "";
                sheetSnapOpen();
            }

            function endSheetDrag(e) {
                if (!sheetDrag.active || e.pointerId !== sheetDrag.id) return;
                try { e.currentTarget.releasePointerCapture(e.pointerId); } catch { }
                sheetDrag.active = false;
                sheetDrag.id = null;

                ui.sheet.style.transition = ""; // restore CSS transition for snap
                momentumOrSnap();

                sheetDrag.dy = 0;
                sheetDrag.vy = 0;
            }

            // 1) Grab handle: always draggable
            ui.grabWrap.addEventListener("pointerdown", (e) => {
                e.preventDefault();
                beginSheetDrag(e);
            }, { passive: false });

            ui.grabWrap.addEventListener("pointermove", moveSheetDrag, { passive: true });
            ui.grabWrap.addEventListener("pointerup", endSheetDrag, { passive: true });
            ui.grabWrap.addEventListener("pointercancel", endSheetDrag, { passive: true });

            // 2) Fling anywhere on sheet (optional): only if not starting on interactive control
            ui.sheetCard.addEventListener("pointerdown", (e) => {
                // if menu closed, ignore
                if (!ui.sheet.classList.contains("open")) return;

                // if user started on buttons/selects, don't hijack
                // (grabWrap is already handled separately)
                if (isInteractive(e.target) || e.target.closest("#grabWrap")) return;

                e.preventDefault();
                beginSheetDrag(e);
            }, { passive: false });

            ui.sheetCard.addEventListener("pointermove", (e) => {
                if (!sheetDrag.active) return;
                moveSheetDrag(e);
            }, { passive: true });

            ui.sheetCard.addEventListener("pointerup", (e) => {
                if (!sheetDrag.active) return;
                endSheetDrag(e);
            }, { passive: true });

            ui.sheetCard.addEventListener("pointercancel", (e) => {
                if (!sheetDrag.active) return;
                endSheetDrag(e);
            }, { passive: true });

            // Menu actions
            ui.startResumeBtn.addEventListener("click", () => {
                if (!state.running) {
                    state.running = true;
                    state.paused = true;
                    state.gameOver = false;
                    resetPositions();
                    showToast("Tap to serve", 1.0);
                } else {
                    if (!state.gameOver) state.paused = true;
                    showToast("Tap to serve", 1.0);
                }
                closeSheet();
            });

            ui.resetMatchBtn.addEventListener("click", () => {
                state.scoreYou = 0; state.scoreAI = 0;
                ui.sYou.textContent = "0"; ui.sAI.textContent = "0";
                state.running = true;
                state.paused = true;
                state.gameOver = false;
                resetPositions();
                showToast("Tap to serve", 1.0);
                closeSheet();
            });

            ui.diffSel.addEventListener("change", () => { state.diff = ui.diffSel.value; });
            ui.personaSel.addEventListener("change", () => { state.persona = ui.personaSel.value; });

            ui.resetLearningBtn.addEventListener("click", () => {
                try { localStorage.removeItem(PROFILE_KEY); } catch { }
                profile = makeFreshProfile();
                updateProfileUI();
            });

            // Core helpers
            function resetPositions() {
                const { w, h } = dims();
                puck.x = w / 2; puck.y = h / 2; puck.vx = 0; puck.vy = 0; puck.glow = 0;
                you.x = w / 2; you.y = h * 0.78; you.vx = you.vy = 0;
                ai.x = w / 2; ai.y = h * 0.22; ai.vx = ai.vy = 0;
                state.youTarget = { x: w / 2, y: h * 0.78 };
                sparks.length = 0;
                state.lastPuckV.vx = 0; state.lastPuckV.vy = 0;
            }

            function serve() {
                if (!state.running || !state.paused || state.gameOver) return;
                ensureAudio();
                const dir = (Math.random() < 0.5) ? -1 : 1;
                const ang = (Math.random() * 0.55 - 0.275);
                const speed = 560;
                puck.vx = Math.sin(ang) * speed;
                puck.vy = dir * Math.cos(ang) * speed;
                state.paused = false;
                state.toastT = 0;
            }

            function collideDiscSafe(pad) {
                const dx = puck.x - pad.x;
                const dy = puck.y - pad.y;
                const dist = Math.hypot(dx, dy);
                const minD = pad.r + puck.r;
                if (dist <= 0.0001 || dist >= minD) return false;

                const nx = dx / dist, ny = dy / dist;
                const overlap = (minD - dist);
                puck.x += nx * overlap;
                puck.y += ny * overlap;

                const rvx = puck.vx - pad.vx;
                const rvy = puck.vy - pad.vy;
                const vn = rvx * nx + rvy * ny;
                if (vn > 0) return true;

                const restitution = 0.985;
                const j = -(1 + restitution) * vn;
                puck.vx += j * nx;
                puck.vy += j * ny;

                puck.vx += pad.vx * 0.32;
                puck.vy += pad.vy * 0.32;

                const tx = -ny, ty = nx;
                const vt = rvx * tx + rvy * ty;
                puck.vx += tx * vt * 0.02;
                puck.vy += ty * vt * 0.02;

                const hit = clamp(Math.abs(vn) / 950, 0, 1);
                puck.glow = Math.min(1, puck.glow + 0.55 * hit);
                sfx.hit(hit);
                addSparks(puck.x, puck.y, 10 + Math.floor(10 * hit), hit);
                vibrate(hit > 0.55 ? [12, 18, 12] : 10);
                return true;
            }

            function puckWallsGoals() {
                const { w, h } = dims();
                const goalW = w * table.goalWidthFrac;
                const gx1 = (w - goalW) / 2;
                const gx2 = (w + goalW) / 2;
                const inMouth = (puck.x > gx1 && puck.x < gx2);

                if (puck.y - puck.r <= table.wall) {
                    if (inMouth) { onGoal("you"); return; }
                    puck.y = table.wall + puck.r;
                    puck.vy = Math.abs(puck.vy) * 0.985;
                    sfx.wall(); vibrate(6);
                }
                if (puck.y + puck.r >= h - table.wall) {
                    if (inMouth) { onGoal("ai"); return; }
                    puck.y = (h - table.wall) - puck.r;
                    puck.vy = -Math.abs(puck.vy) * 0.985;
                    sfx.wall(); vibrate(6);
                }

                if (puck.x - puck.r <= table.wall) {
                    puck.x = table.wall + puck.r;
                    puck.vx = Math.abs(puck.vx) * 0.985;
                    sfx.wall(); vibrate(6);
                }
                if (puck.x + puck.r >= w - table.wall) {
                    puck.x = (w - table.wall) - puck.r;
                    puck.vx = -Math.abs(puck.vx) * 0.985;
                    sfx.wall(); vibrate(6);
                }
            }

            function onGoal(who) {
                sfx.goal();
                vibrate([18, 24, 18]);

                if (who === "you") state.scoreYou++;
                else state.scoreAI++;

                ui.sYou.textContent = String(state.scoreYou);
                ui.sAI.textContent = String(state.scoreAI);

                if (state.scoreYou >= GAME.targetScore || state.scoreAI >= GAME.targetScore) {
                    state.paused = true;
                    state.gameOver = true;
                    showToast(state.scoreYou > state.scoreAI ? "You win — open Menu" : "AI wins — open Menu", 2.0);
                    sfx.win();
                    vibrate([30, 40, 30, 40, 30]);
                    puck.vx = puck.vy = 0;
                    return;
                }

                resetPositions();
                state.paused = true;
                showToast(who === "you" ? "Goal! Tap to serve" : "AI scored — tap to serve", 1.4);
            }

            function movePad(pad, target, dt, speed, half) {
                const { w, h } = dims();
                const mid = h / 2;

                let tx = clamp(target.x, table.pad, w - table.pad);
                let ty = target.y;
                if (half === "bottom") ty = clamp(ty, mid + table.pad, h - table.pad);
                else ty = clamp(ty, table.pad, mid - table.pad);

                const dx = tx - pad.x, dy = ty - pad.y;
                const dist = Math.hypot(dx, dy);

                if (dist > 0.001) {
                    const step = Math.min(speed * dt, dist);
                    const nx = dx / dist, ny = dy / dist;
                    const nxp = pad.x + nx * step;
                    const nyp = pad.y + ny * step;
                    pad.vx = (nxp - pad.x) / dt;
                    pad.vy = (nyp - pad.y) / dt;
                    pad.x = nxp; pad.y = nyp;
                } else {
                    pad.vx *= 0.45; pad.vy *= 0.45;
                }
            }

            // AI helpers
            function predictPuckXAtY(targetY) {
                const { w } = dims();
                const left = table.wall + puck.r;
                const right = (w - table.wall) - puck.r;

                let x = puck.x, y = puck.y, vx = puck.vx, vy = puck.vy;
                if (Math.abs(vy) < 15) return x;

                for (let i = 0; i < 160; i++) {
                    const dt = 1 / 240;
                    x += vx * dt; y += vy * dt;
                    if (x <= left) { x = left + (left - x); vx = Math.abs(vx); }
                    if (x >= right) { x = right - (x - right); vx = -Math.abs(vx); }
                    if ((vy < 0 && y <= targetY) || (vy > 0 && y >= targetY)) return x;
                }
                return x;
            }

            function reflectXForBank(targetX) {
                const { w } = dims();
                const left = table.wall + puck.r;
                const right = (w - table.wall) - puck.r;
                const goLeft = puck.x > w / 2;
                return goLeft ? (left - (targetX - left)) : (right + (right - targetX));
            }

            function legendaryCounterCorner(goalLeftX, goalRightX) {
                if (profile.samples < 10) return (puck.x > (goalLeftX + goalRightX) / 2) ? goalLeftX : goalRightX;
                if (profile.emaShotDir > 0.12) return goalLeftX;
                if (profile.emaShotDir < -0.12) return goalRightX;
                return (puck.x > (goalLeftX + goalRightX) / 2) ? goalLeftX : goalRightX;
            }

            function computeAiTarget() {
                const { w, h } = dims();
                const midY = h / 2;
                const P = effectiveAIParams();

                let interceptY = h * 0.26;
                interceptY *= clamp(P.goalieSnap, 0.9, 1.25);

                const puckInAiHalf = (puck.y < midY);
                const puckComingUp = (puck.vy < -40);

                if (puckComingUp || puckInAiHalf) {
                    const px = predictPuckXAtY(interceptY);
                    return { x: clamp(px, table.pad, w - table.pad), y: clamp(interceptY, table.pad, midY - table.pad) };
                }

                const pressureY = clamp(h * (0.26 + 0.18 * P.pressure), table.pad, midY - table.pad);
                return { x: clamp(puck.x, table.pad, w - table.pad), y: pressureY };
            }

            function aiShotAssist() {
                const { w, h } = dims();
                const P = effectiveAIParams();

                const dx = puck.x - ai.x, dy = puck.y - ai.y;
                const dist = Math.hypot(dx, dy);
                if (dist > 145) return null;

                const goalW = w * table.goalWidthFrac;
                const gx1 = (w - goalW) / 2;
                const gx2 = (w + goalW) / 2;

                const targetCorner = (state.diff === "legendary")
                    ? legendaryCounterCorner(gx1 + 12, gx2 - 12)
                    : (puck.x > w / 2 ? (gx1 + 12) : (gx2 - 12));

                const offCenter = Math.abs(puck.x - w / 2) / (w / 2);
                const bankChance = clamp(P.bankBias * (0.35 + offCenter), 0, 0.95);
                const useBank = (Math.random() < bankChance) && (offCenter > 0.15);

                let aimX = targetCorner;
                if (state.persona === "trickshot" && Math.random() < P.trickRate) {
                    aimX = (puck.x > w / 2) ? (gx2 - 10) : (gx1 + 10);
                }

                const aimY = h - table.wall - 6;
                const finalAimX = useBank ? reflectXForBank(aimX) : aimX;

                const vx = finalAimX - puck.x;
                const vy = aimY - puck.y;
                const L = Math.hypot(vx, vy) || 1;
                const backoff = 28 * (0.9 + 0.2 * P.shotPower);

                const tx = puck.x - (vx / L) * backoff;
                const ty = puck.y - (vy / L) * backoff;

                const midY = h / 2;
                return { x: clamp(tx, table.pad, w - table.pad), y: clamp(ty, table.pad, midY - table.pad) };
            }

            function updateLearningOnHit() {
                const base = baseParamsByDifficulty(state.diff);
                const learnRate = base.learn;
                if (learnRate <= 0) return;

                const dir = clamp(puck.vx / (Math.abs(puck.vx) + 250), -1, 1);
                const a = learnRate;

                profile.samples = (profile.samples || 0) + 1;
                profile.emaShotDir = profile.emaShotDir + a * (dir - profile.emaShotDir);
                profile.lastUpdate = Date.now();

                if (profile.samples % 5 === 0) saveProfile(profile);
                updateProfileUI();
            }

            function step(dt) {
                const { w, h } = dims();
                const mid = h / 2;

                if (state.toastT > 0) state.toastT = Math.max(0, state.toastT - dt);

                // Player moves via drag target (bottom half)
                const tx = clamp(state.youTarget.x || you.x, table.pad, w - table.pad);
                const ty = clamp(state.youTarget.y || you.y, mid + table.pad, h - table.pad);
                movePad(you, { x: tx, y: ty }, dt, 2600, "bottom");

                // AI
                const P = effectiveAIParams();
                const base = computeAiTarget();
                const shot = aiShotAssist();
                const aTarget = shot || base;
                movePad(ai, aTarget, dt, P.speed, "top");

                // particles
                for (let i = sparks.length - 1; i >= 0; i--) {
                    const s = sparks[i];
                    s.life -= dt;
                    s.x += s.vx * dt;
                    s.y += s.vy * dt;
                    s.vx *= Math.exp(-5.5 * dt);
                    s.vy *= Math.exp(-5.5 * dt);
                    if (s.life <= 0) sparks.splice(i, 1);
                }
                puck.glow *= Math.exp(-6.5 * dt);

                if (state.paused || state.gameOver || !state.running) return;

                state.lastPuckV.vx = puck.vx;
                state.lastPuckV.vy = puck.vy;

                puck.x += puck.vx * dt;
                puck.y += puck.vy * dt;

                const fr = Math.exp(-0.66 * dt);
                puck.vx *= fr; puck.vy *= fr;

                const sp = Math.hypot(puck.vx, puck.vy);
                if (sp > puck.max) {
                    const k = puck.max / sp;
                    puck.vx *= k; puck.vy *= k;
                }

                const hitYou = collideDiscSafe(you);
                if (hitYou) {
                    const dv = Math.hypot(puck.vx - state.lastPuckV.vx, puck.vy - state.lastPuckV.vy);
                    if (dv > 60) updateLearningOnHit();
                }
                collideDiscSafe(ai);

                puckWallsGoals();

                if (Math.hypot(puck.vx, puck.vy) < 18) {
                    puck.vx += (Math.random() * 2 - 1) * 10;
                    puck.vy += (Math.random() * 2 - 1) * 10;
                }
            }

            function draw() {
                const { w, h } = dims();
                const mid = h / 2;

                ctx.fillStyle = "#070b12";
                ctx.fillRect(0, 0, w, h);

                const g = ctx.createLinearGradient(0, 0, 0, h);
                g.addColorStop(0, "#0c1a2a");
                g.addColorStop(0.55, "#0b2036");
                g.addColorStop(1, "#071522");
                ctx.fillStyle = g;
                ctx.fillRect(0, 0, w, h);

                drawRailGlow(w, h);

                // walls
                ctx.fillStyle = "rgba(255,255,255,.10)";
                ctx.fillRect(0, 0, w, table.wall);
                ctx.fillRect(0, h - table.wall, w, table.wall);
                ctx.fillRect(0, 0, table.wall, h);
                ctx.fillRect(w - table.wall, 0, table.wall, h);

                // goals
                const goalW = w * table.goalWidthFrac;
                const gx1 = (w - goalW) / 2;
                ctx.fillStyle = "rgba(0,0,0,.35)";
                ctx.fillRect(gx1, 0, goalW, table.wall);
                ctx.fillRect(gx1, h - table.wall, goalW, table.wall);

                // center
                ctx.strokeStyle = "rgba(233,240,255,.25)";
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(0, mid); ctx.lineTo(w, mid); ctx.stroke();
                ctx.beginPath(); ctx.arc(w / 2, mid, 62, 0, Math.PI * 2); ctx.stroke();

                drawPaddle(ai, "#e9f0ff", "#0b0f14", "AI");
                drawPaddle(you, "#ffd66e", "#0b0f14", "YOU");

                for (const s of sparks) {
                    const a = clamp(s.life / 0.35, 0, 1);
                    ctx.globalAlpha = a;
                    ctx.fillStyle = "rgba(255,214,110,.9)";
                    ctx.fillRect(s.x, s.y, 2, 2);
                }
                ctx.globalAlpha = 1;

                drawPuck();

                // Small “Tap to Serve” indicator near player paddle
                if (state.running && state.paused && !state.gameOver && !ui.sheet.classList.contains("open")) {
                    drawServeHint();
                }

                // Toasts near player paddle
                if (state.toastT > 0 && state.toastText) {
                    drawToastNearPaddle(state.toastText, state.toastT);
                }
            }

            function drawServeHint() {
                const { w, h } = dims();
                const text = "Tap to serve";
                const px = clamp(you.x, 70, w - 70);
                const py = clamp(you.y - you.r - 34, 18, h - 18);

                ctx.save();
                ctx.font = "900 13px system-ui,-apple-system,Segoe UI,Roboto,sans-serif";
                const padX = 12;
                const tw = ctx.measureText(text).width;
                const bw = tw + padX * 2;
                const bh = 28;

                const x = px - bw / 2;
                const y = py - bh / 2;

                ctx.globalAlpha = 0.92;
                roundRect(ctx, x, y, bw, bh, 999);
                ctx.fillStyle = "rgba(18,26,36,.84)";
                ctx.fill();
                ctx.strokeStyle = "rgba(255,255,255,.12)";
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.globalAlpha = 0.45;
                ctx.strokeStyle = "rgba(255,214,110,.25)";
                ctx.lineWidth = 2;
                roundRect(ctx, x + 2, y + 2, bw - 4, bh - 4, 999);
                ctx.stroke();

                ctx.globalAlpha = 1;
                ctx.fillStyle = "rgba(233,240,255,.92)";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(text, px, y + bh / 2);
                ctx.restore();
            }

            function drawToastNearPaddle(text, tLeft) {
                const { w, h } = dims();
                const a = clamp(tLeft / 0.35, 0, 1);
                const px = clamp(you.x, 90, w - 90);
                const py = clamp(you.y - you.r - 62, 26, h - 26);

                ctx.save();
                ctx.globalAlpha = 0.88 * a;
                ctx.font = "950 13px system-ui,-apple-system,Segoe UI,Roboto,sans-serif";
                const padX = 12;
                const tw = ctx.measureText(text).width;
                const bw = tw + padX * 2;
                const bh = 30;
                const x = px - bw / 2;
                const y = py - bh / 2;

                roundRect(ctx, x, y, bw, bh, 12);
                ctx.fillStyle = "rgba(0,0,0,.42)";
                ctx.fill();
                ctx.strokeStyle = "rgba(255,255,255,.14)";
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.fillStyle = "rgba(233,240,255,.95)";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(text, px, y + bh / 2);
                ctx.restore();
            }

            function roundRect(ctx, x, y, w, h, r) {
                const rr = Math.min(r, w / 2, h / 2);
                ctx.beginPath();
                ctx.moveTo(x + rr, y);
                ctx.arcTo(x + w, y, x + w, y + h, rr);
                ctx.arcTo(x + w, y + h, x, y + h, rr);
                ctx.arcTo(x, y + h, x, y, rr);
                ctx.arcTo(x, y, x + w, y, rr);
                ctx.closePath();
            }

            function drawRailGlow(w, h) {
                const gl = ctx.createLinearGradient(0, 0, 0, h);
                gl.addColorStop(0, "rgba(42,165,255,.22)");
                gl.addColorStop(0.5, "rgba(42,165,255,.08)");
                gl.addColorStop(1, "rgba(42,165,255,.22)");
                ctx.fillStyle = gl;
                ctx.fillRect(0, 0, 14, h);

                const gr = ctx.createLinearGradient(0, 0, 0, h);
                gr.addColorStop(0, "rgba(255,214,110,.20)");
                gr.addColorStop(0.5, "rgba(255,214,110,.08)");
                gr.addColorStop(1, "rgba(255,214,110,.20)");
                ctx.fillStyle = gr;
                ctx.fillRect(w - 14, 0, 14, h);
            }

            function drawPaddle(p, main, inner, label) {
                ctx.save();
                ctx.globalAlpha = 0.25;
                ctx.fillStyle = "#000";
                ctx.beginPath(); ctx.arc(p.x, p.y + 3, p.r, 0, Math.PI * 2); ctx.fill();
                ctx.restore();

                ctx.fillStyle = main;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2); ctx.fill();

                ctx.fillStyle = inner;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.r * 0.46, 0, Math.PI * 2); ctx.fill();

                ctx.globalAlpha = 0.18;
                ctx.fillStyle = "#fff";
                ctx.beginPath(); ctx.arc(p.x - p.r * 0.25, p.y - p.r * 0.25, p.r * 0.35, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;

                ctx.save();
                ctx.fillStyle = "rgba(0,0,0,.50)";
                ctx.font = "900 10px system-ui,-apple-system,Segoe UI,Roboto,sans-serif";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(label, p.x, p.y);
                ctx.restore();
            }

            function drawPuck() {
                if (puck.glow > 0.02) {
                    ctx.save();
                    ctx.globalAlpha = 0.35 * puck.glow;
                    const rg = ctx.createRadialGradient(puck.x, puck.y, 2, puck.x, puck.y, 34);
                    rg.addColorStop(0, "rgba(255,214,110,1)");
                    rg.addColorStop(1, "rgba(255,214,110,0)");
                    ctx.fillStyle = rg;
                    ctx.beginPath(); ctx.arc(puck.x, puck.y, 34, 0, Math.PI * 2); ctx.fill();
                    ctx.restore();
                }

                ctx.save();
                ctx.globalAlpha = 0.22;
                ctx.fillStyle = "#000";
                ctx.beginPath(); ctx.arc(puck.x, puck.y + 3, puck.r, 0, Math.PI * 2); ctx.fill();

                ctx.globalAlpha = 1;
                ctx.fillStyle = "#0b0f14";
                ctx.beginPath(); ctx.arc(puck.x, puck.y, puck.r, 0, Math.PI * 2); ctx.fill();

                ctx.globalAlpha = 0.22;
                ctx.fillStyle = "#e9f0ff";
                ctx.beginPath(); ctx.arc(puck.x - 3, puck.y - 3, puck.r * 0.55, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            }

            function loop(now) {
                const frameDt = Math.min(GAME.maxFrame, (now - state.last) / 1000);
                state.last = now;
                state.acc += frameDt;

                while (state.acc >= GAME.fixedDt) {
                    step(GAME.fixedDt);
                    state.acc -= GAME.fixedDt;
                }

                draw();
                requestAnimationFrame(loop);
            }

            // Init
            resetPositions();
            openSheet(); // show menu at start
            requestAnimationFrame(loop);
        })();
    </script>
</body>

</html>